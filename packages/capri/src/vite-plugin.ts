import fs from "fs";
import path from "path";
import type { PluginContext, RollupOptions } from "rollup";
import type { Plugin } from "vite";

import { getCssLinks, getEntryFile } from "./chunks.js";
import { EntryScripts, getEntryScripts } from "./entry.js";
import { CapriPluginOptions } from "./options.js";
import { Output } from "./output.js";
import { addUnwrapped, urlToFileName } from "./path-utils.js";
import { renderStaticPages } from "./prerender.js";
import { generateSitemap } from "./sitemap.js";
import { injectWrapperPlugin, resolveWrapper } from "./wrapper.js";

export * from "./options.js";

export function capri({
  createIndexFiles = false,
  prerender = "/",
  followLinks = true,
  islandGlobPattern = "/src/**/*.island.*",
  adapter,
  spa = "/preview",
  commonJs = false,
  inlineCss = false,
  sitemap,
}: CapriPluginOptions): Plugin[] {
  let ssrBuild: boolean;
  let devServer: boolean;

  /** The project's root directory as defined in Vite config or the cwd */
  let rootDir: string;

  let entry: EntryScripts;

  /** The content of index.html as generated by the client build */
  let template: string;

  let output: Output;

  return [
    /**
     * The main Capri plugin.
     */
    {
      enforce: "pre", // modify the bundle before vite:build-html runs
      name: "vite-plugin-capri-main",

      config(config, env) {
        ssrBuild = !!config.build?.ssr;
        devServer = env.mode === "development";
        rootDir = path.resolve(config.root ?? "");

        // Allow base to be set via env:
        const base = config.base ?? process.env.BASE_URL ?? "/";
        const outDir = path.resolve(rootDir, config.build?.outDir ?? "dist");
        output = new Output(outDir, createIndexFiles, base);

        // Add .html so that it isn't treated as JS file
        if (spa) spa = urlToFileName(spa);

        entry = getEntryScripts(rootDir);

        if (ssrBuild) {
          // Read the index.html produced by the client build, so we can use it
          // as template for all pre-rendered pages.
          const indexHtml = path.join(outDir, "index.html");
          template = fs.readFileSync(indexHtml, "utf8");
          fs.rmSync(indexHtml);
          let rollupOptions: RollupOptions | undefined;
          if (commonJs) {
            rollupOptions = {
              output: {
                format: "cjs",
              },
            };
          }

          return {
            base,
            define: {
              "process.env.SSR": "true",
            },
            ssr: {
              // The capri packages can't be externalized as they need to be
              // processed by Vite (virtual modules and glob imports).
              noExternal: ["capri", /@capri-js\//],
            },
            build: {
              ssr: entry.server,
              emptyOutDir: false, // keep the client build
              emitAssets: true,
              rollupOptions,
            },
          };
        } else {
          // Client build ...
          let rollupOptions: RollupOptions = {};
          if (!entry.client) {
            // index.html points to a .server.* file
            if (spa) {
              throw new Error(
                "In order to generate an SPA, index.html must point to a client entry file.",
              );
            }
          } else if (spa) {
            // Generate two entry chunks:
            rollupOptions = {
              input: {
                index: "/index.html",
                spa,
              },
            };
          }
          return {
            base,
            build: {
              rollupOptions,
              modulePreload: {
                // Setting modulePreload to `false` does not work as expected.
                // As workaround, we provide a no-op resolver:
                resolveDependencies(f, deps, context) {
                  return [];
                },
              },
            },
          };
        }
      },

      /**
       * Hook to resolve some virtual modules and, most importantly, wrap
       * islands with the code provided by the framework adapter.
       */
      async resolveId(source, importer, options) {
        if (source === spa) {
          // The spa file is not a real file but will be handled by load().
          // Return the virtual path as-is:
          return spa;
        }

        if (source === "virtual:capri-hydration") {
          // The hydration script. This is also a virtual module that will be
          // handled by load().
          return { id: "\0virtual:capri-hydration", moduleSideEffects: true };
        }

        if (source === "virtual:capri-hydration-adapter") {
          // Framework adapters provide a module for the actual hydration ...
          return this.resolve(adapter.hydrate);
        }

        if (source.includes("?unwrapped")) {
          // The unmodified version of a module is requested, nothing to do ...
          return;
        }

        // Try to resolve the requested module
        const resolved = await this.resolve(source, importer, {
          ...options,
          skipSelf: true,
        });

        if (resolved) {
          const { id } = resolved;
          const isEntry = id === entry.client || id === entry.server;
          if (isEntry && !devServer) {
            // Use the wrapper mechanism to make sure that clients always get
            // the hydration script as entry:
            return resolveWrapper(id, rootDir, "*", {
              client: resolveRelative("./virtual/client.js"),
            });
          }

          // Wrap islands ...
          return resolveWrapper(id, rootDir, islandGlobPattern, adapter.island);
        }
      },

      /**
       * Hook to modify some of the files we are interested in.
       */
      async load(id) {
        if (id === spa) {
          // Load the preview html file, aka the SPA version of our site.
          // That file itself does not exist. Instead we return the actual
          // index.html, but with a rewritten entry script path.
          const index = await resolveIndexHtml(this);

          // ... we add ?unwrapped to the entry script path so that the
          // original version is used and not the hydration script:
          const rewritten = addUnwrapped(entry.raw);

          return fs.readFileSync(index, "utf8").replace(entry.raw, rewritten);
        }

        if (id === "\0virtual:capri-hydration") {
          // Load the hydration script and inject the `islandGlobPattern`.
          const file = resolveRelative("./virtual/hydration.js");
          return fs
            .readFileSync(file, "utf8")
            .replace(/%ISLAND_GLOB_PATTERN%/g, islandGlobPattern);
        }
      },

      /**
       * Hook to transform @capri-js packages with the @capri-transform marker.
       */
      transform(code: string, id: string) {
        if (
          id.includes("node_modules/@capri-js/") &&
          code.match(/\/\/\s*@capri-transform\b/)
        ) {
          return code;
        }
      },

      async writeBundle(_options, bundle) {
        if (ssrBuild) {
          const entryFile = getEntryFile(bundle);
          const ssrBundle = path.resolve(output.dir, entryFile);
          const cssLinks = getCssLinks(bundle, output.base);

          // Prerender pages...
          const urls = await renderStaticPages({
            ssrBundle,
            template,
            cssLinks,
            output,
            prerender,
            followLinks,
            inlineCss,
          });
          fs.rmSync(ssrBundle);
          if (sitemap) {
            await generateSitemap(urls, output, sitemap);
          }
        }
      },
    },
    injectWrapperPlugin(adapter.injectWrapper),
  ];
}

function resolveRelative(src: string) {
  return new URL(src, import.meta.url).pathname;
}

async function resolveIndexHtml(ctx: PluginContext) {
  const index = await ctx.resolve("/index.html");
  if (!index) throw new Error("Can't resolve index.html");
  return index.id;
}
