import * as path from "path";
import type { PluginContext, RollupOptions } from "rollup";
import type { Plugin } from "vite";

import { serverAssetsPlugins } from "./assets.js";
import { EntryScripts, getEntryScripts } from "./entry.js";
import * as fsutils from "./fsutils.js";
import { CapriPluginOptions } from "./options.js";
import { renderStaticPages, urlToFileName } from "./prerender.js";
import { addUnwrapped } from "./utils.js";
import { injectWrapperPlugin, resolveWrapper } from "./wrapper.js";

export * from "./options.js";

export function capri({
  createIndexFiles = false,
  prerender = "/",
  followLinks = true,
  islandGlobPattern = "/src/**/*.island.*",
  lagoonGlobPattern = "/src/**/*.lagoon.*",
  adapter,
  target,
  spa = "/preview",
}: CapriPluginOptions): Plugin[] {
  const ssr = resolveRelative("./virtual/ssr.js");

  let ssrBuild: boolean;
  let devServer: boolean;

  let entry: EntryScripts;

  /** The project's root directory as defined in Vite config or the cwd */
  let rootDir: string;

  /** Absolute path of the build output dir */
  let outDir: string;

  /** The BASE_URL */
  let base: string;

  /** The content of index.html as generated by the client build */
  let template: string;

  return [
    /**
     * The main Capri plugin.
     */
    {
      enforce: "pre", // modify the bundle before vite:build-html runs
      name: "vite-plugin-capri-main",

      config(config, env) {
        config.appType = "mpa";
        ssrBuild = !!config.build?.ssr;
        devServer = env.mode === "development";

        rootDir = path.resolve(config.root ?? "");
        outDir = path.resolve(rootDir, config.build?.outDir ?? "dist");

        entry = getEntryScripts(rootDir);

        // Allow base to be set via env:
        base = config.base ?? process.env.BASE_URL ?? "/";

        if (spa)
          spa = path.resolve(
            rootDir,
            urlToFileName(spa, createIndexFiles, base)
          );

        if (ssrBuild) {
          // Read the index.html produced by the client build, so we can use it
          // as template for all pre-rendered pages.
          const indexHtml = path.join(outDir, "index.html");
          template = fsutils.read(indexHtml);
          fsutils.rm(indexHtml);

          return {
            base,
            define: {
              "process.env.SSR": "true",
            },
            ssr: {
              // The capri packages can't be externalized as they need to be
              // processed by Vite (virtual modules and glob imports).
              noExternal: ["capri", /@capri-js\//],
            },
            build: {
              ssr,
              emptyOutDir: false, // keep the client build
            },
          };
        } else {
          // Client build ...
          let rollupOptions: RollupOptions = {};
          if (!entry.client) {
            // index.html points to a .server.* file
            if (spa) {
              throw new Error(
                "In order to generate an SPA, index.html must point to a client entry file."
              );
            }
          } else if (spa) {
            // Generate two entry chunks:
            rollupOptions = {
              input: {
                index: "/index.html",
                spa,
              },
            };
          }
          return {
            base,
            build: {
              rollupOptions,
              modulePreload: {
                // Setting modulePreload to `false` does not work as expected.
                // As workaround, we provide a no-op resolver:
                resolveDependencies(f, deps, context) {
                  return [];
                },
              },
            },
          };
        }
      },

      /**
       * Hook to resolve some virtual modules and, most importantly, wrap
       * islands and lagoons with the code provided by the framework adapter.
       */
      async resolveId(source, importer, options) {
        if (source === spa) {
          // The spa file is not a real file but will be handled by load().
          // Return the virtual path as-is:
          return spa;
        }

        if (source === "virtual:capri-hydration") {
          // The hydration script. This is also a virtual module that will be
          // handled by load().
          return { id: "\0virtual:capri-hydration", moduleSideEffects: true };
        }

        if (source === "virtual:capri-hydration-adapter") {
          // Framework adapters provide a module for the actual hydration ...
          return this.resolve(adapter.hydrate);
        }

        if (source === "virtual:capri-server-entry") {
          // This is used by ./virtual/ssr.ts to import the server entry ...
          return entry.server;
        }

        if (source.includes("?unwrapped")) {
          // The unmodified version of a module is requested, nothing to do ...
          return;
        }

        // Try to resolve the requested module
        const resolved = await this.resolve(source, importer, {
          ...options,
          skipSelf: true,
        });

        if (resolved) {
          const { id } = resolved;
          const isEntry = id === entry.client || id === entry.server;
          if (isEntry && !devServer) {
            // Use the wrapper mechanism to make sure that clients always get
            // the hydration script as entry:
            return resolveWrapper(id, rootDir, "*", {
              client: resolveRelative("./virtual/client.js"),
            });
          }

          // Wrap islands and lagoons ...
          return (
            resolveWrapper(id, rootDir, islandGlobPattern, adapter.island) ??
            resolveWrapper(id, rootDir, lagoonGlobPattern, adapter.lagoon)
          );
        }
      },

      /**
       * Hook to modify some of the files we are interested in.
       */
      async load(id) {
        if (id === spa) {
          // Load the preview html file, aka the SPA version of our site.
          // That file itself does not exist. Instead we return the actual
          // index.html, but with a rewritten entry script path.
          const index = await resolveIndexHtml(this);

          // ... we add ?unwrapped to the entry script path so that the
          // original version is used and not the hydration script:
          const rewritten = addUnwrapped(entry.raw);

          return fsutils.read(index).replace(entry.raw, rewritten);
        }

        if (id === "\0virtual:capri-hydration") {
          // Load the hydration script and inject the `islandGlobPattern`.
          const file = resolveRelative("./virtual/hydration.js");
          return fsutils
            .read(file)
            .replace(/%ISLAND_GLOB_PATTERN%/g, islandGlobPattern);
        }

        if (id === ssr) {
          // Load the virtual ssr module and inject the index.html
          return fsutils
            .read(ssr)
            .replace('"%TEMPLATE%"', JSON.stringify(template));
        }
      },

      async writeBundle(options, bundle) {
        if (ssrBuild) {
          const ssrBundle = path.resolve(outDir, "ssr.js");

          // Prerender pages...
          await renderStaticPages({
            ssrBundle,
            createIndexFiles,
            outDir,
            base,
            prerender,
            followLinks,
          });

          // Hook for build targets
          if (typeof target === "string") {
            fsutils.copy(ssrBundle, await resolveFile(this, target));
          }
          fsutils.rm(ssrBundle);
        }
      },
    },
    injectWrapperPlugin(adapter.injectWrapper),
    ...serverAssetsPlugins(),
  ];
}

function resolveRelative(src: string) {
  return new URL(src, import.meta.url).pathname;
}

async function resolveFile(ctx: PluginContext, f: string) {
  const index = await resolveIndexHtml(ctx);
  return path.join(path.dirname(index), f);
}

async function resolveIndexHtml(ctx: PluginContext) {
  const index = await ctx.resolve("/index.html");
  if (!index) throw new Error("Can't resolve index.html");
  return index.id;
}
